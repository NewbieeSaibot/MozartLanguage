Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> { command }
Rule 2     command -> command command
Rule 3     command -> loop
Rule 4     command -> if_conditional
Rule 5     command -> if_else_conditional
Rule 6     command -> variable_attribution END
Rule 7     command -> variable_declaration END
Rule 8     command -> register_command END
Rule 9     loop -> WHILE ( logic_expression ) { command }
Rule 10    if_conditional -> IF ( logic_expression ) { command }
Rule 11    if_else_conditional -> IF ( logic_expression ) { command } ELSE { command }
Rule 12    register_command -> REGISTER ( expression )
Rule 13    arithmetic_operator -> PLUS
Rule 14    arithmetic_operator -> MINUS
Rule 15    arithmetic_operator -> TIMES
Rule 16    arithmetic_operator -> DIVISION
Rule 17    arithmetic_operator -> MODULO
Rule 18    binary_logic_operator -> AND
Rule 19    binary_logic_operator -> OR
Rule 20    unary_logic_operator -> NOT
Rule 21    comparative_operator -> GT
Rule 22    comparative_operator -> LT
Rule 23    comparative_operator -> GE
Rule 24    comparative_operator -> LE
Rule 25    comparative_operator -> EQUAL
Rule 26    comparative_operator -> NOT_EQUAL
Rule 27    unary_operator -> unary_logic_operator
Rule 28    binary_operator -> arithmetic_operator
Rule 29    binary_operator -> comparative_operator
Rule 30    binary_operator -> binary_logic_operator
Rule 31    note -> ( REAL COMMA REAL COMMA INTEGER )
Rule 32    integer_list -> INTEGER
Rule 33    integer_list -> integer_list COMMA INTEGER
Rule 34    scale -> [ integer_list ]
Rule 35    chord -> ( INTEGER COMMA INTEGER COMMA INTEGER )
Rule 36    chord_list -> chord
Rule 37    chord_list -> chord_list COMMA chord
Rule 38    harmonic_field -> [ chord_list ]
Rule 39    note_list -> note
Rule 40    note_list -> note_list COMMA note
Rule 41    music -> ( [ note_list ] COMMA REAL )
Rule 42    music -> ( [ ] COMMA REAL )
Rule 43    variable_attribution -> IDENTIFIER = expression
Rule 44    variable_declaration -> VARIABLE_TYPE IDENTIFIER = expression
Rule 45    literal -> note
Rule 46    literal -> scale
Rule 47    literal -> chord
Rule 48    literal -> harmonic_field
Rule 49    literal -> music
Rule 50    literal -> INTEGER
Rule 51    literal -> REAL
Rule 52    literal -> BOOLEAN
Rule 53    expression -> arithmetic_expression
Rule 54    expression -> logic_expression
Rule 55    expression -> literal
Rule 56    expression -> builtin_functions
Rule 57    builtin_functions -> PREDEFINED_IDENTIFIER ( params_list )
Rule 58    params_list -> expression
Rule 59    params_list -> params_list COMMA expression
Rule 60    arithmetic_expression -> IDENTIFIER
Rule 61    arithmetic_expression -> arithmetic_literal
Rule 62    arithmetic_expression -> ( arithmetic_expression )
Rule 63    arithmetic_expression -> arithmetic_expression arithmetic_operator arithmetic_expression
Rule 64    logic_expression -> BOOLEAN
Rule 65    logic_expression -> IDENTIFIER
Rule 66    logic_expression -> ( logic_expression )
Rule 67    logic_expression -> ( arithmetic_expression comparative_operator arithmetic_expression )
Rule 68    logic_expression -> logic_expression binary_logic_operator logic_expression
Rule 69    logic_expression -> unary_logic_operator logic_expression
Rule 70    arithmetic_literal -> REAL
Rule 71    arithmetic_literal -> INTEGER

Terminals, with rules where they appear

(                    : 9 10 11 12 31 35 41 42 57 62 66 67
)                    : 9 10 11 12 31 35 41 42 57 62 66 67
=                    : 43 44
AND                  : 18
BOOLEAN              : 52 64
COMMA                : 31 31 33 35 35 37 40 41 42 59
DIVISION             : 16
ELSE                 : 11
END                  : 6 7 8
EQUAL                : 25
GE                   : 23
GT                   : 21
IDENTIFIER           : 43 44 60 65
IF                   : 10 11
INTEGER              : 31 32 33 35 35 35 50 71
LE                   : 24
LT                   : 22
MINUS                : 14
MODULO               : 17
NOT                  : 20
NOT_EQUAL            : 26
OR                   : 19
PLUS                 : 13
PREDEFINED_IDENTIFIER : 57
REAL                 : 31 31 41 42 51 70
REGISTER             : 12
TIMES                : 15
VARIABLE_TYPE        : 44
WHILE                : 9
[                    : 34 38 41 42
]                    : 34 38 41 42
error                : 
{                    : 1 9 10 11 11
}                    : 1 9 10 11 11

Nonterminals, with rules where they appear

arithmetic_expression : 53 62 63 63 67 67
arithmetic_literal   : 61
arithmetic_operator  : 28 63
binary_logic_operator : 30 68
binary_operator      : 
builtin_functions    : 56
chord                : 36 37 47
chord_list           : 37 38
command              : 1 2 2 9 10 11 11
comparative_operator : 29 67
expression           : 12 43 44 58 59
harmonic_field       : 48
if_conditional       : 4
if_else_conditional  : 5
integer_list         : 33 34
literal              : 55
logic_expression     : 9 10 11 54 66 68 68 69
loop                 : 3
music                : 49
note                 : 39 40 45
note_list            : 40 41
params_list          : 57 59
program              : 0
register_command     : 8
scale                : 46
unary_logic_operator : 27 69
unary_operator       : 
variable_attribution : 6
variable_declaration : 7

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . { command }

    {               shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> { . command }
    (2) command -> . command command
    (3) command -> . loop
    (4) command -> . if_conditional
    (5) command -> . if_else_conditional
    (6) command -> . variable_attribution END
    (7) command -> . variable_declaration END
    (8) command -> . register_command END
    (9) loop -> . WHILE ( logic_expression ) { command }
    (10) if_conditional -> . IF ( logic_expression ) { command }
    (11) if_else_conditional -> . IF ( logic_expression ) { command } ELSE { command }
    (43) variable_attribution -> . IDENTIFIER = expression
    (44) variable_declaration -> . VARIABLE_TYPE IDENTIFIER = expression
    (12) register_command -> . REGISTER ( expression )

    WHILE           shift and go to state 10
    IF              shift and go to state 11
    IDENTIFIER      shift and go to state 12
    VARIABLE_TYPE   shift and go to state 13
    REGISTER        shift and go to state 14

    command                        shift and go to state 3
    loop                           shift and go to state 4
    if_conditional                 shift and go to state 5
    if_else_conditional            shift and go to state 6
    variable_attribution           shift and go to state 7
    variable_declaration           shift and go to state 8
    register_command               shift and go to state 9

state 3

    (1) program -> { command . }
    (2) command -> command . command
    (2) command -> . command command
    (3) command -> . loop
    (4) command -> . if_conditional
    (5) command -> . if_else_conditional
    (6) command -> . variable_attribution END
    (7) command -> . variable_declaration END
    (8) command -> . register_command END
    (9) loop -> . WHILE ( logic_expression ) { command }
    (10) if_conditional -> . IF ( logic_expression ) { command }
    (11) if_else_conditional -> . IF ( logic_expression ) { command } ELSE { command }
    (43) variable_attribution -> . IDENTIFIER = expression
    (44) variable_declaration -> . VARIABLE_TYPE IDENTIFIER = expression
    (12) register_command -> . REGISTER ( expression )

    }               shift and go to state 16
    WHILE           shift and go to state 10
    IF              shift and go to state 11
    IDENTIFIER      shift and go to state 12
    VARIABLE_TYPE   shift and go to state 13
    REGISTER        shift and go to state 14

    command                        shift and go to state 15
    loop                           shift and go to state 4
    if_conditional                 shift and go to state 5
    if_else_conditional            shift and go to state 6
    variable_attribution           shift and go to state 7
    variable_declaration           shift and go to state 8
    register_command               shift and go to state 9

state 4

    (3) command -> loop .

    }               reduce using rule 3 (command -> loop .)
    WHILE           reduce using rule 3 (command -> loop .)
    IF              reduce using rule 3 (command -> loop .)
    IDENTIFIER      reduce using rule 3 (command -> loop .)
    VARIABLE_TYPE   reduce using rule 3 (command -> loop .)
    REGISTER        reduce using rule 3 (command -> loop .)


state 5

    (4) command -> if_conditional .

    }               reduce using rule 4 (command -> if_conditional .)
    WHILE           reduce using rule 4 (command -> if_conditional .)
    IF              reduce using rule 4 (command -> if_conditional .)
    IDENTIFIER      reduce using rule 4 (command -> if_conditional .)
    VARIABLE_TYPE   reduce using rule 4 (command -> if_conditional .)
    REGISTER        reduce using rule 4 (command -> if_conditional .)


state 6

    (5) command -> if_else_conditional .

    }               reduce using rule 5 (command -> if_else_conditional .)
    WHILE           reduce using rule 5 (command -> if_else_conditional .)
    IF              reduce using rule 5 (command -> if_else_conditional .)
    IDENTIFIER      reduce using rule 5 (command -> if_else_conditional .)
    VARIABLE_TYPE   reduce using rule 5 (command -> if_else_conditional .)
    REGISTER        reduce using rule 5 (command -> if_else_conditional .)


state 7

    (6) command -> variable_attribution . END

    END             shift and go to state 17


state 8

    (7) command -> variable_declaration . END

    END             shift and go to state 18


state 9

    (8) command -> register_command . END

    END             shift and go to state 19


state 10

    (9) loop -> WHILE . ( logic_expression ) { command }

    (               shift and go to state 20


state 11

    (10) if_conditional -> IF . ( logic_expression ) { command }
    (11) if_else_conditional -> IF . ( logic_expression ) { command } ELSE { command }

    (               shift and go to state 21


state 12

    (43) variable_attribution -> IDENTIFIER . = expression

    =               shift and go to state 22


state 13

    (44) variable_declaration -> VARIABLE_TYPE . IDENTIFIER = expression

    IDENTIFIER      shift and go to state 23


state 14

    (12) register_command -> REGISTER . ( expression )

    (               shift and go to state 24


state 15

    (2) command -> command command .
    (2) command -> command . command
    (2) command -> . command command
    (3) command -> . loop
    (4) command -> . if_conditional
    (5) command -> . if_else_conditional
    (6) command -> . variable_attribution END
    (7) command -> . variable_declaration END
    (8) command -> . register_command END
    (9) loop -> . WHILE ( logic_expression ) { command }
    (10) if_conditional -> . IF ( logic_expression ) { command }
    (11) if_else_conditional -> . IF ( logic_expression ) { command } ELSE { command }
    (43) variable_attribution -> . IDENTIFIER = expression
    (44) variable_declaration -> . VARIABLE_TYPE IDENTIFIER = expression
    (12) register_command -> . REGISTER ( expression )

  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for VARIABLE_TYPE resolved as shift
  ! shift/reduce conflict for REGISTER resolved as shift
    }               reduce using rule 2 (command -> command command .)
    WHILE           shift and go to state 10
    IF              shift and go to state 11
    IDENTIFIER      shift and go to state 12
    VARIABLE_TYPE   shift and go to state 13
    REGISTER        shift and go to state 14

  ! WHILE           [ reduce using rule 2 (command -> command command .) ]
  ! IF              [ reduce using rule 2 (command -> command command .) ]
  ! IDENTIFIER      [ reduce using rule 2 (command -> command command .) ]
  ! VARIABLE_TYPE   [ reduce using rule 2 (command -> command command .) ]
  ! REGISTER        [ reduce using rule 2 (command -> command command .) ]

    command                        shift and go to state 15
    loop                           shift and go to state 4
    if_conditional                 shift and go to state 5
    if_else_conditional            shift and go to state 6
    variable_attribution           shift and go to state 7
    variable_declaration           shift and go to state 8
    register_command               shift and go to state 9

state 16

    (1) program -> { command } .

    $end            reduce using rule 1 (program -> { command } .)


state 17

    (6) command -> variable_attribution END .

    }               reduce using rule 6 (command -> variable_attribution END .)
    WHILE           reduce using rule 6 (command -> variable_attribution END .)
    IF              reduce using rule 6 (command -> variable_attribution END .)
    IDENTIFIER      reduce using rule 6 (command -> variable_attribution END .)
    VARIABLE_TYPE   reduce using rule 6 (command -> variable_attribution END .)
    REGISTER        reduce using rule 6 (command -> variable_attribution END .)


state 18

    (7) command -> variable_declaration END .

    }               reduce using rule 7 (command -> variable_declaration END .)
    WHILE           reduce using rule 7 (command -> variable_declaration END .)
    IF              reduce using rule 7 (command -> variable_declaration END .)
    IDENTIFIER      reduce using rule 7 (command -> variable_declaration END .)
    VARIABLE_TYPE   reduce using rule 7 (command -> variable_declaration END .)
    REGISTER        reduce using rule 7 (command -> variable_declaration END .)


state 19

    (8) command -> register_command END .

    }               reduce using rule 8 (command -> register_command END .)
    WHILE           reduce using rule 8 (command -> register_command END .)
    IF              reduce using rule 8 (command -> register_command END .)
    IDENTIFIER      reduce using rule 8 (command -> register_command END .)
    VARIABLE_TYPE   reduce using rule 8 (command -> register_command END .)
    REGISTER        reduce using rule 8 (command -> register_command END .)


state 20

    (9) loop -> WHILE ( . logic_expression ) { command }
    (64) logic_expression -> . BOOLEAN
    (65) logic_expression -> . IDENTIFIER
    (66) logic_expression -> . ( logic_expression )
    (67) logic_expression -> . ( arithmetic_expression comparative_operator arithmetic_expression )
    (68) logic_expression -> . logic_expression binary_logic_operator logic_expression
    (69) logic_expression -> . unary_logic_operator logic_expression
    (20) unary_logic_operator -> . NOT

    BOOLEAN         shift and go to state 27
    IDENTIFIER      shift and go to state 28
    (               shift and go to state 25
    NOT             shift and go to state 30

    logic_expression               shift and go to state 26
    unary_logic_operator           shift and go to state 29

state 21

    (10) if_conditional -> IF ( . logic_expression ) { command }
    (11) if_else_conditional -> IF ( . logic_expression ) { command } ELSE { command }
    (64) logic_expression -> . BOOLEAN
    (65) logic_expression -> . IDENTIFIER
    (66) logic_expression -> . ( logic_expression )
    (67) logic_expression -> . ( arithmetic_expression comparative_operator arithmetic_expression )
    (68) logic_expression -> . logic_expression binary_logic_operator logic_expression
    (69) logic_expression -> . unary_logic_operator logic_expression
    (20) unary_logic_operator -> . NOT

    BOOLEAN         shift and go to state 27
    IDENTIFIER      shift and go to state 28
    (               shift and go to state 25
    NOT             shift and go to state 30

    logic_expression               shift and go to state 31
    unary_logic_operator           shift and go to state 29

state 22

    (43) variable_attribution -> IDENTIFIER = . expression
    (53) expression -> . arithmetic_expression
    (54) expression -> . logic_expression
    (55) expression -> . literal
    (56) expression -> . builtin_functions
    (60) arithmetic_expression -> . IDENTIFIER
    (61) arithmetic_expression -> . arithmetic_literal
    (62) arithmetic_expression -> . ( arithmetic_expression )
    (63) arithmetic_expression -> . arithmetic_expression arithmetic_operator arithmetic_expression
    (64) logic_expression -> . BOOLEAN
    (65) logic_expression -> . IDENTIFIER
    (66) logic_expression -> . ( logic_expression )
    (67) logic_expression -> . ( arithmetic_expression comparative_operator arithmetic_expression )
    (68) logic_expression -> . logic_expression binary_logic_operator logic_expression
    (69) logic_expression -> . unary_logic_operator logic_expression
    (45) literal -> . note
    (46) literal -> . scale
    (47) literal -> . chord
    (48) literal -> . harmonic_field
    (49) literal -> . music
    (50) literal -> . INTEGER
    (51) literal -> . REAL
    (52) literal -> . BOOLEAN
    (57) builtin_functions -> . PREDEFINED_IDENTIFIER ( params_list )
    (70) arithmetic_literal -> . REAL
    (71) arithmetic_literal -> . INTEGER
    (20) unary_logic_operator -> . NOT
    (31) note -> . ( REAL COMMA REAL COMMA INTEGER )
    (34) scale -> . [ integer_list ]
    (35) chord -> . ( INTEGER COMMA INTEGER COMMA INTEGER )
    (38) harmonic_field -> . [ chord_list ]
    (41) music -> . ( [ note_list ] COMMA REAL )
    (42) music -> . ( [ ] COMMA REAL )

    IDENTIFIER      shift and go to state 32
    (               shift and go to state 39
    BOOLEAN         shift and go to state 40
    INTEGER         shift and go to state 46
    REAL            shift and go to state 47
    PREDEFINED_IDENTIFIER shift and go to state 48
    NOT             shift and go to state 30
    [               shift and go to state 49

    expression                     shift and go to state 33
    arithmetic_expression          shift and go to state 34
    logic_expression               shift and go to state 35
    literal                        shift and go to state 36
    builtin_functions              shift and go to state 37
    arithmetic_literal             shift and go to state 38
    unary_logic_operator           shift and go to state 29
    note                           shift and go to state 41
    scale                          shift and go to state 42
    chord                          shift and go to state 43
    harmonic_field                 shift and go to state 44
    music                          shift and go to state 45

state 23

    (44) variable_declaration -> VARIABLE_TYPE IDENTIFIER . = expression

    =               shift and go to state 50


state 24

    (12) register_command -> REGISTER ( . expression )
    (53) expression -> . arithmetic_expression
    (54) expression -> . logic_expression
    (55) expression -> . literal
    (56) expression -> . builtin_functions
    (60) arithmetic_expression -> . IDENTIFIER
    (61) arithmetic_expression -> . arithmetic_literal
    (62) arithmetic_expression -> . ( arithmetic_expression )
    (63) arithmetic_expression -> . arithmetic_expression arithmetic_operator arithmetic_expression
    (64) logic_expression -> . BOOLEAN
    (65) logic_expression -> . IDENTIFIER
    (66) logic_expression -> . ( logic_expression )
    (67) logic_expression -> . ( arithmetic_expression comparative_operator arithmetic_expression )
    (68) logic_expression -> . logic_expression binary_logic_operator logic_expression
    (69) logic_expression -> . unary_logic_operator logic_expression
    (45) literal -> . note
    (46) literal -> . scale
    (47) literal -> . chord
    (48) literal -> . harmonic_field
    (49) literal -> . music
    (50) literal -> . INTEGER
    (51) literal -> . REAL
    (52) literal -> . BOOLEAN
    (57) builtin_functions -> . PREDEFINED_IDENTIFIER ( params_list )
    (70) arithmetic_literal -> . REAL
    (71) arithmetic_literal -> . INTEGER
    (20) unary_logic_operator -> . NOT
    (31) note -> . ( REAL COMMA REAL COMMA INTEGER )
    (34) scale -> . [ integer_list ]
    (35) chord -> . ( INTEGER COMMA INTEGER COMMA INTEGER )
    (38) harmonic_field -> . [ chord_list ]
    (41) music -> . ( [ note_list ] COMMA REAL )
    (42) music -> . ( [ ] COMMA REAL )

    IDENTIFIER      shift and go to state 32
    (               shift and go to state 39
    BOOLEAN         shift and go to state 40
    INTEGER         shift and go to state 46
    REAL            shift and go to state 47
    PREDEFINED_IDENTIFIER shift and go to state 48
    NOT             shift and go to state 30
    [               shift and go to state 49

    expression                     shift and go to state 51
    arithmetic_expression          shift and go to state 34
    logic_expression               shift and go to state 35
    literal                        shift and go to state 36
    builtin_functions              shift and go to state 37
    arithmetic_literal             shift and go to state 38
    unary_logic_operator           shift and go to state 29
    note                           shift and go to state 41
    scale                          shift and go to state 42
    chord                          shift and go to state 43
    harmonic_field                 shift and go to state 44
    music                          shift and go to state 45

state 25

    (66) logic_expression -> ( . logic_expression )
    (67) logic_expression -> ( . arithmetic_expression comparative_operator arithmetic_expression )
    (64) logic_expression -> . BOOLEAN
    (65) logic_expression -> . IDENTIFIER
    (66) logic_expression -> . ( logic_expression )
    (67) logic_expression -> . ( arithmetic_expression comparative_operator arithmetic_expression )
    (68) logic_expression -> . logic_expression binary_logic_operator logic_expression
    (69) logic_expression -> . unary_logic_operator logic_expression
    (60) arithmetic_expression -> . IDENTIFIER
    (61) arithmetic_expression -> . arithmetic_literal
    (62) arithmetic_expression -> . ( arithmetic_expression )
    (63) arithmetic_expression -> . arithmetic_expression arithmetic_operator arithmetic_expression
    (20) unary_logic_operator -> . NOT
    (70) arithmetic_literal -> . REAL
    (71) arithmetic_literal -> . INTEGER

    BOOLEAN         shift and go to state 27
    IDENTIFIER      shift and go to state 55
    (               shift and go to state 52
    NOT             shift and go to state 30
    REAL            shift and go to state 56
    INTEGER         shift and go to state 57

    logic_expression               shift and go to state 53
    arithmetic_expression          shift and go to state 54
    unary_logic_operator           shift and go to state 29
    arithmetic_literal             shift and go to state 38

state 26

    (9) loop -> WHILE ( logic_expression . ) { command }
    (68) logic_expression -> logic_expression . binary_logic_operator logic_expression
    (18) binary_logic_operator -> . AND
    (19) binary_logic_operator -> . OR

    )               shift and go to state 58
    AND             shift and go to state 60
    OR              shift and go to state 61

    binary_logic_operator          shift and go to state 59

state 27

    (64) logic_expression -> BOOLEAN .

    )               reduce using rule 64 (logic_expression -> BOOLEAN .)
    AND             reduce using rule 64 (logic_expression -> BOOLEAN .)
    OR              reduce using rule 64 (logic_expression -> BOOLEAN .)
    END             reduce using rule 64 (logic_expression -> BOOLEAN .)
    COMMA           reduce using rule 64 (logic_expression -> BOOLEAN .)


state 28

    (65) logic_expression -> IDENTIFIER .

    )               reduce using rule 65 (logic_expression -> IDENTIFIER .)
    AND             reduce using rule 65 (logic_expression -> IDENTIFIER .)
    OR              reduce using rule 65 (logic_expression -> IDENTIFIER .)
    END             reduce using rule 65 (logic_expression -> IDENTIFIER .)
    COMMA           reduce using rule 65 (logic_expression -> IDENTIFIER .)


state 29

    (69) logic_expression -> unary_logic_operator . logic_expression
    (64) logic_expression -> . BOOLEAN
    (65) logic_expression -> . IDENTIFIER
    (66) logic_expression -> . ( logic_expression )
    (67) logic_expression -> . ( arithmetic_expression comparative_operator arithmetic_expression )
    (68) logic_expression -> . logic_expression binary_logic_operator logic_expression
    (69) logic_expression -> . unary_logic_operator logic_expression
    (20) unary_logic_operator -> . NOT

    BOOLEAN         shift and go to state 27
    IDENTIFIER      shift and go to state 28
    (               shift and go to state 25
    NOT             shift and go to state 30

    unary_logic_operator           shift and go to state 29
    logic_expression               shift and go to state 62

state 30

    (20) unary_logic_operator -> NOT .

    BOOLEAN         reduce using rule 20 (unary_logic_operator -> NOT .)
    IDENTIFIER      reduce using rule 20 (unary_logic_operator -> NOT .)
    (               reduce using rule 20 (unary_logic_operator -> NOT .)
    NOT             reduce using rule 20 (unary_logic_operator -> NOT .)


state 31

    (10) if_conditional -> IF ( logic_expression . ) { command }
    (11) if_else_conditional -> IF ( logic_expression . ) { command } ELSE { command }
    (68) logic_expression -> logic_expression . binary_logic_operator logic_expression
    (18) binary_logic_operator -> . AND
    (19) binary_logic_operator -> . OR

    )               shift and go to state 63
    AND             shift and go to state 60
    OR              shift and go to state 61

    binary_logic_operator          shift and go to state 59

state 32

    (60) arithmetic_expression -> IDENTIFIER .
    (65) logic_expression -> IDENTIFIER .

  ! reduce/reduce conflict for END resolved using rule 60 (arithmetic_expression -> IDENTIFIER .)
  ! reduce/reduce conflict for ) resolved using rule 60 (arithmetic_expression -> IDENTIFIER .)
  ! reduce/reduce conflict for COMMA resolved using rule 60 (arithmetic_expression -> IDENTIFIER .)
    PLUS            reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    MINUS           reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    TIMES           reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    DIVISION        reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    MODULO          reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    END             reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    )               reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    GT              reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    LT              reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    GE              reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    LE              reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    EQUAL           reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    COMMA           reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    AND             reduce using rule 65 (logic_expression -> IDENTIFIER .)
    OR              reduce using rule 65 (logic_expression -> IDENTIFIER .)

  ! END             [ reduce using rule 65 (logic_expression -> IDENTIFIER .) ]
  ! )               [ reduce using rule 65 (logic_expression -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 65 (logic_expression -> IDENTIFIER .) ]


state 33

    (43) variable_attribution -> IDENTIFIER = expression .

    END             reduce using rule 43 (variable_attribution -> IDENTIFIER = expression .)


state 34

    (53) expression -> arithmetic_expression .
    (63) arithmetic_expression -> arithmetic_expression . arithmetic_operator arithmetic_expression
    (13) arithmetic_operator -> . PLUS
    (14) arithmetic_operator -> . MINUS
    (15) arithmetic_operator -> . TIMES
    (16) arithmetic_operator -> . DIVISION
    (17) arithmetic_operator -> . MODULO

    END             reduce using rule 53 (expression -> arithmetic_expression .)
    )               reduce using rule 53 (expression -> arithmetic_expression .)
    COMMA           reduce using rule 53 (expression -> arithmetic_expression .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVISION        shift and go to state 68
    MODULO          shift and go to state 69

    arithmetic_operator            shift and go to state 64

state 35

    (54) expression -> logic_expression .
    (68) logic_expression -> logic_expression . binary_logic_operator logic_expression
    (18) binary_logic_operator -> . AND
    (19) binary_logic_operator -> . OR

    END             reduce using rule 54 (expression -> logic_expression .)
    )               reduce using rule 54 (expression -> logic_expression .)
    COMMA           reduce using rule 54 (expression -> logic_expression .)
    AND             shift and go to state 60
    OR              shift and go to state 61

    binary_logic_operator          shift and go to state 59

state 36

    (55) expression -> literal .

    END             reduce using rule 55 (expression -> literal .)
    )               reduce using rule 55 (expression -> literal .)
    COMMA           reduce using rule 55 (expression -> literal .)


state 37

    (56) expression -> builtin_functions .

    END             reduce using rule 56 (expression -> builtin_functions .)
    )               reduce using rule 56 (expression -> builtin_functions .)
    COMMA           reduce using rule 56 (expression -> builtin_functions .)


state 38

    (61) arithmetic_expression -> arithmetic_literal .

    PLUS            reduce using rule 61 (arithmetic_expression -> arithmetic_literal .)
    MINUS           reduce using rule 61 (arithmetic_expression -> arithmetic_literal .)
    TIMES           reduce using rule 61 (arithmetic_expression -> arithmetic_literal .)
    DIVISION        reduce using rule 61 (arithmetic_expression -> arithmetic_literal .)
    MODULO          reduce using rule 61 (arithmetic_expression -> arithmetic_literal .)
    END             reduce using rule 61 (arithmetic_expression -> arithmetic_literal .)
    )               reduce using rule 61 (arithmetic_expression -> arithmetic_literal .)
    GT              reduce using rule 61 (arithmetic_expression -> arithmetic_literal .)
    LT              reduce using rule 61 (arithmetic_expression -> arithmetic_literal .)
    GE              reduce using rule 61 (arithmetic_expression -> arithmetic_literal .)
    LE              reduce using rule 61 (arithmetic_expression -> arithmetic_literal .)
    EQUAL           reduce using rule 61 (arithmetic_expression -> arithmetic_literal .)
    NOT_EQUAL       reduce using rule 61 (arithmetic_expression -> arithmetic_literal .)
    COMMA           reduce using rule 61 (arithmetic_expression -> arithmetic_literal .)


state 39

    (62) arithmetic_expression -> ( . arithmetic_expression )
    (66) logic_expression -> ( . logic_expression )
    (67) logic_expression -> ( . arithmetic_expression comparative_operator arithmetic_expression )
    (31) note -> ( . REAL COMMA REAL COMMA INTEGER )
    (35) chord -> ( . INTEGER COMMA INTEGER COMMA INTEGER )
    (41) music -> ( . [ note_list ] COMMA REAL )
    (42) music -> ( . [ ] COMMA REAL )
    (60) arithmetic_expression -> . IDENTIFIER
    (61) arithmetic_expression -> . arithmetic_literal
    (62) arithmetic_expression -> . ( arithmetic_expression )
    (63) arithmetic_expression -> . arithmetic_expression arithmetic_operator arithmetic_expression
    (64) logic_expression -> . BOOLEAN
    (65) logic_expression -> . IDENTIFIER
    (66) logic_expression -> . ( logic_expression )
    (67) logic_expression -> . ( arithmetic_expression comparative_operator arithmetic_expression )
    (68) logic_expression -> . logic_expression binary_logic_operator logic_expression
    (69) logic_expression -> . unary_logic_operator logic_expression
    (70) arithmetic_literal -> . REAL
    (71) arithmetic_literal -> . INTEGER
    (20) unary_logic_operator -> . NOT

    REAL            shift and go to state 72
    INTEGER         shift and go to state 73
    [               shift and go to state 74
    IDENTIFIER      shift and go to state 32
    (               shift and go to state 70
    BOOLEAN         shift and go to state 27
    NOT             shift and go to state 30

    arithmetic_expression          shift and go to state 71
    logic_expression               shift and go to state 53
    arithmetic_literal             shift and go to state 38
    unary_logic_operator           shift and go to state 29

state 40

    (64) logic_expression -> BOOLEAN .
    (52) literal -> BOOLEAN .

  ! reduce/reduce conflict for END resolved using rule 52 (literal -> BOOLEAN .)
  ! reduce/reduce conflict for ) resolved using rule 52 (literal -> BOOLEAN .)
  ! reduce/reduce conflict for COMMA resolved using rule 52 (literal -> BOOLEAN .)
    AND             reduce using rule 64 (logic_expression -> BOOLEAN .)
    OR              reduce using rule 64 (logic_expression -> BOOLEAN .)
    END             reduce using rule 52 (literal -> BOOLEAN .)
    )               reduce using rule 52 (literal -> BOOLEAN .)
    COMMA           reduce using rule 52 (literal -> BOOLEAN .)

  ! END             [ reduce using rule 64 (logic_expression -> BOOLEAN .) ]
  ! )               [ reduce using rule 64 (logic_expression -> BOOLEAN .) ]
  ! COMMA           [ reduce using rule 64 (logic_expression -> BOOLEAN .) ]


state 41

    (45) literal -> note .

    END             reduce using rule 45 (literal -> note .)
    )               reduce using rule 45 (literal -> note .)
    COMMA           reduce using rule 45 (literal -> note .)


state 42

    (46) literal -> scale .

    END             reduce using rule 46 (literal -> scale .)
    )               reduce using rule 46 (literal -> scale .)
    COMMA           reduce using rule 46 (literal -> scale .)


state 43

    (47) literal -> chord .

    END             reduce using rule 47 (literal -> chord .)
    )               reduce using rule 47 (literal -> chord .)
    COMMA           reduce using rule 47 (literal -> chord .)


state 44

    (48) literal -> harmonic_field .

    END             reduce using rule 48 (literal -> harmonic_field .)
    )               reduce using rule 48 (literal -> harmonic_field .)
    COMMA           reduce using rule 48 (literal -> harmonic_field .)


state 45

    (49) literal -> music .

    END             reduce using rule 49 (literal -> music .)
    )               reduce using rule 49 (literal -> music .)
    COMMA           reduce using rule 49 (literal -> music .)


state 46

    (50) literal -> INTEGER .
    (71) arithmetic_literal -> INTEGER .

  ! reduce/reduce conflict for END resolved using rule 50 (literal -> INTEGER .)
  ! reduce/reduce conflict for ) resolved using rule 50 (literal -> INTEGER .)
  ! reduce/reduce conflict for COMMA resolved using rule 50 (literal -> INTEGER .)
    END             reduce using rule 50 (literal -> INTEGER .)
    )               reduce using rule 50 (literal -> INTEGER .)
    COMMA           reduce using rule 50 (literal -> INTEGER .)
    PLUS            reduce using rule 71 (arithmetic_literal -> INTEGER .)
    MINUS           reduce using rule 71 (arithmetic_literal -> INTEGER .)
    TIMES           reduce using rule 71 (arithmetic_literal -> INTEGER .)
    DIVISION        reduce using rule 71 (arithmetic_literal -> INTEGER .)
    MODULO          reduce using rule 71 (arithmetic_literal -> INTEGER .)

  ! END             [ reduce using rule 71 (arithmetic_literal -> INTEGER .) ]
  ! )               [ reduce using rule 71 (arithmetic_literal -> INTEGER .) ]
  ! COMMA           [ reduce using rule 71 (arithmetic_literal -> INTEGER .) ]


state 47

    (51) literal -> REAL .
    (70) arithmetic_literal -> REAL .

  ! reduce/reduce conflict for END resolved using rule 51 (literal -> REAL .)
  ! reduce/reduce conflict for ) resolved using rule 51 (literal -> REAL .)
  ! reduce/reduce conflict for COMMA resolved using rule 51 (literal -> REAL .)
    END             reduce using rule 51 (literal -> REAL .)
    )               reduce using rule 51 (literal -> REAL .)
    COMMA           reduce using rule 51 (literal -> REAL .)
    PLUS            reduce using rule 70 (arithmetic_literal -> REAL .)
    MINUS           reduce using rule 70 (arithmetic_literal -> REAL .)
    TIMES           reduce using rule 70 (arithmetic_literal -> REAL .)
    DIVISION        reduce using rule 70 (arithmetic_literal -> REAL .)
    MODULO          reduce using rule 70 (arithmetic_literal -> REAL .)

  ! END             [ reduce using rule 70 (arithmetic_literal -> REAL .) ]
  ! )               [ reduce using rule 70 (arithmetic_literal -> REAL .) ]
  ! COMMA           [ reduce using rule 70 (arithmetic_literal -> REAL .) ]


state 48

    (57) builtin_functions -> PREDEFINED_IDENTIFIER . ( params_list )

    (               shift and go to state 75


state 49

    (34) scale -> [ . integer_list ]
    (38) harmonic_field -> [ . chord_list ]
    (32) integer_list -> . INTEGER
    (33) integer_list -> . integer_list COMMA INTEGER
    (36) chord_list -> . chord
    (37) chord_list -> . chord_list COMMA chord
    (35) chord -> . ( INTEGER COMMA INTEGER COMMA INTEGER )

    INTEGER         shift and go to state 78
    (               shift and go to state 80

    integer_list                   shift and go to state 76
    chord_list                     shift and go to state 77
    chord                          shift and go to state 79

state 50

    (44) variable_declaration -> VARIABLE_TYPE IDENTIFIER = . expression
    (53) expression -> . arithmetic_expression
    (54) expression -> . logic_expression
    (55) expression -> . literal
    (56) expression -> . builtin_functions
    (60) arithmetic_expression -> . IDENTIFIER
    (61) arithmetic_expression -> . arithmetic_literal
    (62) arithmetic_expression -> . ( arithmetic_expression )
    (63) arithmetic_expression -> . arithmetic_expression arithmetic_operator arithmetic_expression
    (64) logic_expression -> . BOOLEAN
    (65) logic_expression -> . IDENTIFIER
    (66) logic_expression -> . ( logic_expression )
    (67) logic_expression -> . ( arithmetic_expression comparative_operator arithmetic_expression )
    (68) logic_expression -> . logic_expression binary_logic_operator logic_expression
    (69) logic_expression -> . unary_logic_operator logic_expression
    (45) literal -> . note
    (46) literal -> . scale
    (47) literal -> . chord
    (48) literal -> . harmonic_field
    (49) literal -> . music
    (50) literal -> . INTEGER
    (51) literal -> . REAL
    (52) literal -> . BOOLEAN
    (57) builtin_functions -> . PREDEFINED_IDENTIFIER ( params_list )
    (70) arithmetic_literal -> . REAL
    (71) arithmetic_literal -> . INTEGER
    (20) unary_logic_operator -> . NOT
    (31) note -> . ( REAL COMMA REAL COMMA INTEGER )
    (34) scale -> . [ integer_list ]
    (35) chord -> . ( INTEGER COMMA INTEGER COMMA INTEGER )
    (38) harmonic_field -> . [ chord_list ]
    (41) music -> . ( [ note_list ] COMMA REAL )
    (42) music -> . ( [ ] COMMA REAL )

    IDENTIFIER      shift and go to state 32
    (               shift and go to state 39
    BOOLEAN         shift and go to state 40
    INTEGER         shift and go to state 46
    REAL            shift and go to state 47
    PREDEFINED_IDENTIFIER shift and go to state 48
    NOT             shift and go to state 30
    [               shift and go to state 49

    expression                     shift and go to state 81
    arithmetic_expression          shift and go to state 34
    logic_expression               shift and go to state 35
    literal                        shift and go to state 36
    builtin_functions              shift and go to state 37
    arithmetic_literal             shift and go to state 38
    unary_logic_operator           shift and go to state 29
    note                           shift and go to state 41
    scale                          shift and go to state 42
    chord                          shift and go to state 43
    harmonic_field                 shift and go to state 44
    music                          shift and go to state 45

state 51

    (12) register_command -> REGISTER ( expression . )

    )               shift and go to state 82


state 52

    (66) logic_expression -> ( . logic_expression )
    (67) logic_expression -> ( . arithmetic_expression comparative_operator arithmetic_expression )
    (62) arithmetic_expression -> ( . arithmetic_expression )
    (64) logic_expression -> . BOOLEAN
    (65) logic_expression -> . IDENTIFIER
    (66) logic_expression -> . ( logic_expression )
    (67) logic_expression -> . ( arithmetic_expression comparative_operator arithmetic_expression )
    (68) logic_expression -> . logic_expression binary_logic_operator logic_expression
    (69) logic_expression -> . unary_logic_operator logic_expression
    (60) arithmetic_expression -> . IDENTIFIER
    (61) arithmetic_expression -> . arithmetic_literal
    (62) arithmetic_expression -> . ( arithmetic_expression )
    (63) arithmetic_expression -> . arithmetic_expression arithmetic_operator arithmetic_expression
    (20) unary_logic_operator -> . NOT
    (70) arithmetic_literal -> . REAL
    (71) arithmetic_literal -> . INTEGER

    BOOLEAN         shift and go to state 27
    IDENTIFIER      shift and go to state 55
    (               shift and go to state 52
    NOT             shift and go to state 30
    REAL            shift and go to state 56
    INTEGER         shift and go to state 57

    logic_expression               shift and go to state 53
    arithmetic_expression          shift and go to state 83
    unary_logic_operator           shift and go to state 29
    arithmetic_literal             shift and go to state 38

state 53

    (66) logic_expression -> ( logic_expression . )
    (68) logic_expression -> logic_expression . binary_logic_operator logic_expression
    (18) binary_logic_operator -> . AND
    (19) binary_logic_operator -> . OR

    )               shift and go to state 84
    AND             shift and go to state 60
    OR              shift and go to state 61

    binary_logic_operator          shift and go to state 59

state 54

    (67) logic_expression -> ( arithmetic_expression . comparative_operator arithmetic_expression )
    (63) arithmetic_expression -> arithmetic_expression . arithmetic_operator arithmetic_expression
    (21) comparative_operator -> . GT
    (22) comparative_operator -> . LT
    (23) comparative_operator -> . GE
    (24) comparative_operator -> . LE
    (25) comparative_operator -> . EQUAL
    (26) comparative_operator -> . NOT_EQUAL
    (13) arithmetic_operator -> . PLUS
    (14) arithmetic_operator -> . MINUS
    (15) arithmetic_operator -> . TIMES
    (16) arithmetic_operator -> . DIVISION
    (17) arithmetic_operator -> . MODULO

    GT              shift and go to state 86
    LT              shift and go to state 87
    GE              shift and go to state 88
    LE              shift and go to state 89
    EQUAL           shift and go to state 90
    NOT_EQUAL       shift and go to state 91
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVISION        shift and go to state 68
    MODULO          shift and go to state 69

    comparative_operator           shift and go to state 85
    arithmetic_operator            shift and go to state 64

state 55

    (65) logic_expression -> IDENTIFIER .
    (60) arithmetic_expression -> IDENTIFIER .

  ! reduce/reduce conflict for ) resolved using rule 60 (arithmetic_expression -> IDENTIFIER .)
    AND             reduce using rule 65 (logic_expression -> IDENTIFIER .)
    OR              reduce using rule 65 (logic_expression -> IDENTIFIER .)
    GT              reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    LT              reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    GE              reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    LE              reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    EQUAL           reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    PLUS            reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    MINUS           reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    TIMES           reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    DIVISION        reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    MODULO          reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    )               reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)

  ! )               [ reduce using rule 65 (logic_expression -> IDENTIFIER .) ]


state 56

    (70) arithmetic_literal -> REAL .

    GT              reduce using rule 70 (arithmetic_literal -> REAL .)
    LT              reduce using rule 70 (arithmetic_literal -> REAL .)
    GE              reduce using rule 70 (arithmetic_literal -> REAL .)
    LE              reduce using rule 70 (arithmetic_literal -> REAL .)
    EQUAL           reduce using rule 70 (arithmetic_literal -> REAL .)
    NOT_EQUAL       reduce using rule 70 (arithmetic_literal -> REAL .)
    PLUS            reduce using rule 70 (arithmetic_literal -> REAL .)
    MINUS           reduce using rule 70 (arithmetic_literal -> REAL .)
    TIMES           reduce using rule 70 (arithmetic_literal -> REAL .)
    DIVISION        reduce using rule 70 (arithmetic_literal -> REAL .)
    MODULO          reduce using rule 70 (arithmetic_literal -> REAL .)
    )               reduce using rule 70 (arithmetic_literal -> REAL .)
    END             reduce using rule 70 (arithmetic_literal -> REAL .)
    COMMA           reduce using rule 70 (arithmetic_literal -> REAL .)


state 57

    (71) arithmetic_literal -> INTEGER .

    GT              reduce using rule 71 (arithmetic_literal -> INTEGER .)
    LT              reduce using rule 71 (arithmetic_literal -> INTEGER .)
    GE              reduce using rule 71 (arithmetic_literal -> INTEGER .)
    LE              reduce using rule 71 (arithmetic_literal -> INTEGER .)
    EQUAL           reduce using rule 71 (arithmetic_literal -> INTEGER .)
    NOT_EQUAL       reduce using rule 71 (arithmetic_literal -> INTEGER .)
    PLUS            reduce using rule 71 (arithmetic_literal -> INTEGER .)
    MINUS           reduce using rule 71 (arithmetic_literal -> INTEGER .)
    TIMES           reduce using rule 71 (arithmetic_literal -> INTEGER .)
    DIVISION        reduce using rule 71 (arithmetic_literal -> INTEGER .)
    MODULO          reduce using rule 71 (arithmetic_literal -> INTEGER .)
    )               reduce using rule 71 (arithmetic_literal -> INTEGER .)
    END             reduce using rule 71 (arithmetic_literal -> INTEGER .)
    COMMA           reduce using rule 71 (arithmetic_literal -> INTEGER .)


state 58

    (9) loop -> WHILE ( logic_expression ) . { command }

    {               shift and go to state 92


state 59

    (68) logic_expression -> logic_expression binary_logic_operator . logic_expression
    (64) logic_expression -> . BOOLEAN
    (65) logic_expression -> . IDENTIFIER
    (66) logic_expression -> . ( logic_expression )
    (67) logic_expression -> . ( arithmetic_expression comparative_operator arithmetic_expression )
    (68) logic_expression -> . logic_expression binary_logic_operator logic_expression
    (69) logic_expression -> . unary_logic_operator logic_expression
    (20) unary_logic_operator -> . NOT

    BOOLEAN         shift and go to state 27
    IDENTIFIER      shift and go to state 28
    (               shift and go to state 25
    NOT             shift and go to state 30

    logic_expression               shift and go to state 93
    unary_logic_operator           shift and go to state 29

state 60

    (18) binary_logic_operator -> AND .

    BOOLEAN         reduce using rule 18 (binary_logic_operator -> AND .)
    IDENTIFIER      reduce using rule 18 (binary_logic_operator -> AND .)
    (               reduce using rule 18 (binary_logic_operator -> AND .)
    NOT             reduce using rule 18 (binary_logic_operator -> AND .)


state 61

    (19) binary_logic_operator -> OR .

    BOOLEAN         reduce using rule 19 (binary_logic_operator -> OR .)
    IDENTIFIER      reduce using rule 19 (binary_logic_operator -> OR .)
    (               reduce using rule 19 (binary_logic_operator -> OR .)
    NOT             reduce using rule 19 (binary_logic_operator -> OR .)


state 62

    (69) logic_expression -> unary_logic_operator logic_expression .
    (68) logic_expression -> logic_expression . binary_logic_operator logic_expression
    (18) binary_logic_operator -> . AND
    (19) binary_logic_operator -> . OR

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    )               reduce using rule 69 (logic_expression -> unary_logic_operator logic_expression .)
    END             reduce using rule 69 (logic_expression -> unary_logic_operator logic_expression .)
    COMMA           reduce using rule 69 (logic_expression -> unary_logic_operator logic_expression .)
    AND             shift and go to state 60
    OR              shift and go to state 61

  ! AND             [ reduce using rule 69 (logic_expression -> unary_logic_operator logic_expression .) ]
  ! OR              [ reduce using rule 69 (logic_expression -> unary_logic_operator logic_expression .) ]

    binary_logic_operator          shift and go to state 59

state 63

    (10) if_conditional -> IF ( logic_expression ) . { command }
    (11) if_else_conditional -> IF ( logic_expression ) . { command } ELSE { command }

    {               shift and go to state 94


state 64

    (63) arithmetic_expression -> arithmetic_expression arithmetic_operator . arithmetic_expression
    (60) arithmetic_expression -> . IDENTIFIER
    (61) arithmetic_expression -> . arithmetic_literal
    (62) arithmetic_expression -> . ( arithmetic_expression )
    (63) arithmetic_expression -> . arithmetic_expression arithmetic_operator arithmetic_expression
    (70) arithmetic_literal -> . REAL
    (71) arithmetic_literal -> . INTEGER

    IDENTIFIER      shift and go to state 96
    (               shift and go to state 97
    REAL            shift and go to state 56
    INTEGER         shift and go to state 57

    arithmetic_expression          shift and go to state 95
    arithmetic_literal             shift and go to state 38

state 65

    (13) arithmetic_operator -> PLUS .

    IDENTIFIER      reduce using rule 13 (arithmetic_operator -> PLUS .)
    (               reduce using rule 13 (arithmetic_operator -> PLUS .)
    REAL            reduce using rule 13 (arithmetic_operator -> PLUS .)
    INTEGER         reduce using rule 13 (arithmetic_operator -> PLUS .)


state 66

    (14) arithmetic_operator -> MINUS .

    IDENTIFIER      reduce using rule 14 (arithmetic_operator -> MINUS .)
    (               reduce using rule 14 (arithmetic_operator -> MINUS .)
    REAL            reduce using rule 14 (arithmetic_operator -> MINUS .)
    INTEGER         reduce using rule 14 (arithmetic_operator -> MINUS .)


state 67

    (15) arithmetic_operator -> TIMES .

    IDENTIFIER      reduce using rule 15 (arithmetic_operator -> TIMES .)
    (               reduce using rule 15 (arithmetic_operator -> TIMES .)
    REAL            reduce using rule 15 (arithmetic_operator -> TIMES .)
    INTEGER         reduce using rule 15 (arithmetic_operator -> TIMES .)


state 68

    (16) arithmetic_operator -> DIVISION .

    IDENTIFIER      reduce using rule 16 (arithmetic_operator -> DIVISION .)
    (               reduce using rule 16 (arithmetic_operator -> DIVISION .)
    REAL            reduce using rule 16 (arithmetic_operator -> DIVISION .)
    INTEGER         reduce using rule 16 (arithmetic_operator -> DIVISION .)


state 69

    (17) arithmetic_operator -> MODULO .

    IDENTIFIER      reduce using rule 17 (arithmetic_operator -> MODULO .)
    (               reduce using rule 17 (arithmetic_operator -> MODULO .)
    REAL            reduce using rule 17 (arithmetic_operator -> MODULO .)
    INTEGER         reduce using rule 17 (arithmetic_operator -> MODULO .)


state 70

    (62) arithmetic_expression -> ( . arithmetic_expression )
    (66) logic_expression -> ( . logic_expression )
    (67) logic_expression -> ( . arithmetic_expression comparative_operator arithmetic_expression )
    (60) arithmetic_expression -> . IDENTIFIER
    (61) arithmetic_expression -> . arithmetic_literal
    (62) arithmetic_expression -> . ( arithmetic_expression )
    (63) arithmetic_expression -> . arithmetic_expression arithmetic_operator arithmetic_expression
    (64) logic_expression -> . BOOLEAN
    (65) logic_expression -> . IDENTIFIER
    (66) logic_expression -> . ( logic_expression )
    (67) logic_expression -> . ( arithmetic_expression comparative_operator arithmetic_expression )
    (68) logic_expression -> . logic_expression binary_logic_operator logic_expression
    (69) logic_expression -> . unary_logic_operator logic_expression
    (70) arithmetic_literal -> . REAL
    (71) arithmetic_literal -> . INTEGER
    (20) unary_logic_operator -> . NOT

    IDENTIFIER      shift and go to state 32
    (               shift and go to state 70
    BOOLEAN         shift and go to state 27
    REAL            shift and go to state 56
    INTEGER         shift and go to state 57
    NOT             shift and go to state 30

    arithmetic_expression          shift and go to state 71
    logic_expression               shift and go to state 53
    arithmetic_literal             shift and go to state 38
    unary_logic_operator           shift and go to state 29

state 71

    (62) arithmetic_expression -> ( arithmetic_expression . )
    (67) logic_expression -> ( arithmetic_expression . comparative_operator arithmetic_expression )
    (63) arithmetic_expression -> arithmetic_expression . arithmetic_operator arithmetic_expression
    (21) comparative_operator -> . GT
    (22) comparative_operator -> . LT
    (23) comparative_operator -> . GE
    (24) comparative_operator -> . LE
    (25) comparative_operator -> . EQUAL
    (26) comparative_operator -> . NOT_EQUAL
    (13) arithmetic_operator -> . PLUS
    (14) arithmetic_operator -> . MINUS
    (15) arithmetic_operator -> . TIMES
    (16) arithmetic_operator -> . DIVISION
    (17) arithmetic_operator -> . MODULO

    )               shift and go to state 98
    GT              shift and go to state 86
    LT              shift and go to state 87
    GE              shift and go to state 88
    LE              shift and go to state 89
    EQUAL           shift and go to state 90
    NOT_EQUAL       shift and go to state 91
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVISION        shift and go to state 68
    MODULO          shift and go to state 69

    comparative_operator           shift and go to state 85
    arithmetic_operator            shift and go to state 64

state 72

    (31) note -> ( REAL . COMMA REAL COMMA INTEGER )
    (70) arithmetic_literal -> REAL .

    COMMA           shift and go to state 99
    )               reduce using rule 70 (arithmetic_literal -> REAL .)
    GT              reduce using rule 70 (arithmetic_literal -> REAL .)
    LT              reduce using rule 70 (arithmetic_literal -> REAL .)
    GE              reduce using rule 70 (arithmetic_literal -> REAL .)
    LE              reduce using rule 70 (arithmetic_literal -> REAL .)
    EQUAL           reduce using rule 70 (arithmetic_literal -> REAL .)
    NOT_EQUAL       reduce using rule 70 (arithmetic_literal -> REAL .)
    PLUS            reduce using rule 70 (arithmetic_literal -> REAL .)
    MINUS           reduce using rule 70 (arithmetic_literal -> REAL .)
    TIMES           reduce using rule 70 (arithmetic_literal -> REAL .)
    DIVISION        reduce using rule 70 (arithmetic_literal -> REAL .)
    MODULO          reduce using rule 70 (arithmetic_literal -> REAL .)


state 73

    (35) chord -> ( INTEGER . COMMA INTEGER COMMA INTEGER )
    (71) arithmetic_literal -> INTEGER .

    COMMA           shift and go to state 100
    )               reduce using rule 71 (arithmetic_literal -> INTEGER .)
    GT              reduce using rule 71 (arithmetic_literal -> INTEGER .)
    LT              reduce using rule 71 (arithmetic_literal -> INTEGER .)
    GE              reduce using rule 71 (arithmetic_literal -> INTEGER .)
    LE              reduce using rule 71 (arithmetic_literal -> INTEGER .)
    EQUAL           reduce using rule 71 (arithmetic_literal -> INTEGER .)
    NOT_EQUAL       reduce using rule 71 (arithmetic_literal -> INTEGER .)
    PLUS            reduce using rule 71 (arithmetic_literal -> INTEGER .)
    MINUS           reduce using rule 71 (arithmetic_literal -> INTEGER .)
    TIMES           reduce using rule 71 (arithmetic_literal -> INTEGER .)
    DIVISION        reduce using rule 71 (arithmetic_literal -> INTEGER .)
    MODULO          reduce using rule 71 (arithmetic_literal -> INTEGER .)


state 74

    (41) music -> ( [ . note_list ] COMMA REAL )
    (42) music -> ( [ . ] COMMA REAL )
    (39) note_list -> . note
    (40) note_list -> . note_list COMMA note
    (31) note -> . ( REAL COMMA REAL COMMA INTEGER )

    ]               shift and go to state 103
    (               shift and go to state 101

    note_list                      shift and go to state 102
    note                           shift and go to state 104

state 75

    (57) builtin_functions -> PREDEFINED_IDENTIFIER ( . params_list )
    (58) params_list -> . expression
    (59) params_list -> . params_list COMMA expression
    (53) expression -> . arithmetic_expression
    (54) expression -> . logic_expression
    (55) expression -> . literal
    (56) expression -> . builtin_functions
    (60) arithmetic_expression -> . IDENTIFIER
    (61) arithmetic_expression -> . arithmetic_literal
    (62) arithmetic_expression -> . ( arithmetic_expression )
    (63) arithmetic_expression -> . arithmetic_expression arithmetic_operator arithmetic_expression
    (64) logic_expression -> . BOOLEAN
    (65) logic_expression -> . IDENTIFIER
    (66) logic_expression -> . ( logic_expression )
    (67) logic_expression -> . ( arithmetic_expression comparative_operator arithmetic_expression )
    (68) logic_expression -> . logic_expression binary_logic_operator logic_expression
    (69) logic_expression -> . unary_logic_operator logic_expression
    (45) literal -> . note
    (46) literal -> . scale
    (47) literal -> . chord
    (48) literal -> . harmonic_field
    (49) literal -> . music
    (50) literal -> . INTEGER
    (51) literal -> . REAL
    (52) literal -> . BOOLEAN
    (57) builtin_functions -> . PREDEFINED_IDENTIFIER ( params_list )
    (70) arithmetic_literal -> . REAL
    (71) arithmetic_literal -> . INTEGER
    (20) unary_logic_operator -> . NOT
    (31) note -> . ( REAL COMMA REAL COMMA INTEGER )
    (34) scale -> . [ integer_list ]
    (35) chord -> . ( INTEGER COMMA INTEGER COMMA INTEGER )
    (38) harmonic_field -> . [ chord_list ]
    (41) music -> . ( [ note_list ] COMMA REAL )
    (42) music -> . ( [ ] COMMA REAL )

    IDENTIFIER      shift and go to state 32
    (               shift and go to state 39
    BOOLEAN         shift and go to state 40
    INTEGER         shift and go to state 46
    REAL            shift and go to state 47
    PREDEFINED_IDENTIFIER shift and go to state 48
    NOT             shift and go to state 30
    [               shift and go to state 49

    params_list                    shift and go to state 105
    expression                     shift and go to state 106
    arithmetic_expression          shift and go to state 34
    logic_expression               shift and go to state 35
    literal                        shift and go to state 36
    builtin_functions              shift and go to state 37
    arithmetic_literal             shift and go to state 38
    unary_logic_operator           shift and go to state 29
    note                           shift and go to state 41
    scale                          shift and go to state 42
    chord                          shift and go to state 43
    harmonic_field                 shift and go to state 44
    music                          shift and go to state 45

state 76

    (34) scale -> [ integer_list . ]
    (33) integer_list -> integer_list . COMMA INTEGER

    ]               shift and go to state 107
    COMMA           shift and go to state 108


state 77

    (38) harmonic_field -> [ chord_list . ]
    (37) chord_list -> chord_list . COMMA chord

    ]               shift and go to state 109
    COMMA           shift and go to state 110


state 78

    (32) integer_list -> INTEGER .

    ]               reduce using rule 32 (integer_list -> INTEGER .)
    COMMA           reduce using rule 32 (integer_list -> INTEGER .)


state 79

    (36) chord_list -> chord .

    ]               reduce using rule 36 (chord_list -> chord .)
    COMMA           reduce using rule 36 (chord_list -> chord .)


state 80

    (35) chord -> ( . INTEGER COMMA INTEGER COMMA INTEGER )

    INTEGER         shift and go to state 111


state 81

    (44) variable_declaration -> VARIABLE_TYPE IDENTIFIER = expression .

    END             reduce using rule 44 (variable_declaration -> VARIABLE_TYPE IDENTIFIER = expression .)


state 82

    (12) register_command -> REGISTER ( expression ) .

    END             reduce using rule 12 (register_command -> REGISTER ( expression ) .)


state 83

    (67) logic_expression -> ( arithmetic_expression . comparative_operator arithmetic_expression )
    (62) arithmetic_expression -> ( arithmetic_expression . )
    (63) arithmetic_expression -> arithmetic_expression . arithmetic_operator arithmetic_expression
    (21) comparative_operator -> . GT
    (22) comparative_operator -> . LT
    (23) comparative_operator -> . GE
    (24) comparative_operator -> . LE
    (25) comparative_operator -> . EQUAL
    (26) comparative_operator -> . NOT_EQUAL
    (13) arithmetic_operator -> . PLUS
    (14) arithmetic_operator -> . MINUS
    (15) arithmetic_operator -> . TIMES
    (16) arithmetic_operator -> . DIVISION
    (17) arithmetic_operator -> . MODULO

    )               shift and go to state 98
    GT              shift and go to state 86
    LT              shift and go to state 87
    GE              shift and go to state 88
    LE              shift and go to state 89
    EQUAL           shift and go to state 90
    NOT_EQUAL       shift and go to state 91
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVISION        shift and go to state 68
    MODULO          shift and go to state 69

    comparative_operator           shift and go to state 85
    arithmetic_operator            shift and go to state 64

state 84

    (66) logic_expression -> ( logic_expression ) .

    )               reduce using rule 66 (logic_expression -> ( logic_expression ) .)
    AND             reduce using rule 66 (logic_expression -> ( logic_expression ) .)
    OR              reduce using rule 66 (logic_expression -> ( logic_expression ) .)
    END             reduce using rule 66 (logic_expression -> ( logic_expression ) .)
    COMMA           reduce using rule 66 (logic_expression -> ( logic_expression ) .)


state 85

    (67) logic_expression -> ( arithmetic_expression comparative_operator . arithmetic_expression )
    (60) arithmetic_expression -> . IDENTIFIER
    (61) arithmetic_expression -> . arithmetic_literal
    (62) arithmetic_expression -> . ( arithmetic_expression )
    (63) arithmetic_expression -> . arithmetic_expression arithmetic_operator arithmetic_expression
    (70) arithmetic_literal -> . REAL
    (71) arithmetic_literal -> . INTEGER

    IDENTIFIER      shift and go to state 96
    (               shift and go to state 97
    REAL            shift and go to state 56
    INTEGER         shift and go to state 57

    arithmetic_expression          shift and go to state 112
    arithmetic_literal             shift and go to state 38

state 86

    (21) comparative_operator -> GT .

    IDENTIFIER      reduce using rule 21 (comparative_operator -> GT .)
    (               reduce using rule 21 (comparative_operator -> GT .)
    REAL            reduce using rule 21 (comparative_operator -> GT .)
    INTEGER         reduce using rule 21 (comparative_operator -> GT .)


state 87

    (22) comparative_operator -> LT .

    IDENTIFIER      reduce using rule 22 (comparative_operator -> LT .)
    (               reduce using rule 22 (comparative_operator -> LT .)
    REAL            reduce using rule 22 (comparative_operator -> LT .)
    INTEGER         reduce using rule 22 (comparative_operator -> LT .)


state 88

    (23) comparative_operator -> GE .

    IDENTIFIER      reduce using rule 23 (comparative_operator -> GE .)
    (               reduce using rule 23 (comparative_operator -> GE .)
    REAL            reduce using rule 23 (comparative_operator -> GE .)
    INTEGER         reduce using rule 23 (comparative_operator -> GE .)


state 89

    (24) comparative_operator -> LE .

    IDENTIFIER      reduce using rule 24 (comparative_operator -> LE .)
    (               reduce using rule 24 (comparative_operator -> LE .)
    REAL            reduce using rule 24 (comparative_operator -> LE .)
    INTEGER         reduce using rule 24 (comparative_operator -> LE .)


state 90

    (25) comparative_operator -> EQUAL .

    IDENTIFIER      reduce using rule 25 (comparative_operator -> EQUAL .)
    (               reduce using rule 25 (comparative_operator -> EQUAL .)
    REAL            reduce using rule 25 (comparative_operator -> EQUAL .)
    INTEGER         reduce using rule 25 (comparative_operator -> EQUAL .)


state 91

    (26) comparative_operator -> NOT_EQUAL .

    IDENTIFIER      reduce using rule 26 (comparative_operator -> NOT_EQUAL .)
    (               reduce using rule 26 (comparative_operator -> NOT_EQUAL .)
    REAL            reduce using rule 26 (comparative_operator -> NOT_EQUAL .)
    INTEGER         reduce using rule 26 (comparative_operator -> NOT_EQUAL .)


state 92

    (9) loop -> WHILE ( logic_expression ) { . command }
    (2) command -> . command command
    (3) command -> . loop
    (4) command -> . if_conditional
    (5) command -> . if_else_conditional
    (6) command -> . variable_attribution END
    (7) command -> . variable_declaration END
    (8) command -> . register_command END
    (9) loop -> . WHILE ( logic_expression ) { command }
    (10) if_conditional -> . IF ( logic_expression ) { command }
    (11) if_else_conditional -> . IF ( logic_expression ) { command } ELSE { command }
    (43) variable_attribution -> . IDENTIFIER = expression
    (44) variable_declaration -> . VARIABLE_TYPE IDENTIFIER = expression
    (12) register_command -> . REGISTER ( expression )

    WHILE           shift and go to state 10
    IF              shift and go to state 11
    IDENTIFIER      shift and go to state 12
    VARIABLE_TYPE   shift and go to state 13
    REGISTER        shift and go to state 14

    command                        shift and go to state 113
    loop                           shift and go to state 4
    if_conditional                 shift and go to state 5
    if_else_conditional            shift and go to state 6
    variable_attribution           shift and go to state 7
    variable_declaration           shift and go to state 8
    register_command               shift and go to state 9

state 93

    (68) logic_expression -> logic_expression binary_logic_operator logic_expression .
    (68) logic_expression -> logic_expression . binary_logic_operator logic_expression
    (18) binary_logic_operator -> . AND
    (19) binary_logic_operator -> . OR

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    )               reduce using rule 68 (logic_expression -> logic_expression binary_logic_operator logic_expression .)
    END             reduce using rule 68 (logic_expression -> logic_expression binary_logic_operator logic_expression .)
    COMMA           reduce using rule 68 (logic_expression -> logic_expression binary_logic_operator logic_expression .)
    AND             shift and go to state 60
    OR              shift and go to state 61

  ! AND             [ reduce using rule 68 (logic_expression -> logic_expression binary_logic_operator logic_expression .) ]
  ! OR              [ reduce using rule 68 (logic_expression -> logic_expression binary_logic_operator logic_expression .) ]

    binary_logic_operator          shift and go to state 59

state 94

    (10) if_conditional -> IF ( logic_expression ) { . command }
    (11) if_else_conditional -> IF ( logic_expression ) { . command } ELSE { command }
    (2) command -> . command command
    (3) command -> . loop
    (4) command -> . if_conditional
    (5) command -> . if_else_conditional
    (6) command -> . variable_attribution END
    (7) command -> . variable_declaration END
    (8) command -> . register_command END
    (9) loop -> . WHILE ( logic_expression ) { command }
    (10) if_conditional -> . IF ( logic_expression ) { command }
    (11) if_else_conditional -> . IF ( logic_expression ) { command } ELSE { command }
    (43) variable_attribution -> . IDENTIFIER = expression
    (44) variable_declaration -> . VARIABLE_TYPE IDENTIFIER = expression
    (12) register_command -> . REGISTER ( expression )

    WHILE           shift and go to state 10
    IF              shift and go to state 11
    IDENTIFIER      shift and go to state 12
    VARIABLE_TYPE   shift and go to state 13
    REGISTER        shift and go to state 14

    command                        shift and go to state 114
    loop                           shift and go to state 4
    if_conditional                 shift and go to state 5
    if_else_conditional            shift and go to state 6
    variable_attribution           shift and go to state 7
    variable_declaration           shift and go to state 8
    register_command               shift and go to state 9

state 95

    (63) arithmetic_expression -> arithmetic_expression arithmetic_operator arithmetic_expression .
    (63) arithmetic_expression -> arithmetic_expression . arithmetic_operator arithmetic_expression
    (13) arithmetic_operator -> . PLUS
    (14) arithmetic_operator -> . MINUS
    (15) arithmetic_operator -> . TIMES
    (16) arithmetic_operator -> . DIVISION
    (17) arithmetic_operator -> . MODULO

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
    END             reduce using rule 63 (arithmetic_expression -> arithmetic_expression arithmetic_operator arithmetic_expression .)
    )               reduce using rule 63 (arithmetic_expression -> arithmetic_expression arithmetic_operator arithmetic_expression .)
    GT              reduce using rule 63 (arithmetic_expression -> arithmetic_expression arithmetic_operator arithmetic_expression .)
    LT              reduce using rule 63 (arithmetic_expression -> arithmetic_expression arithmetic_operator arithmetic_expression .)
    GE              reduce using rule 63 (arithmetic_expression -> arithmetic_expression arithmetic_operator arithmetic_expression .)
    LE              reduce using rule 63 (arithmetic_expression -> arithmetic_expression arithmetic_operator arithmetic_expression .)
    EQUAL           reduce using rule 63 (arithmetic_expression -> arithmetic_expression arithmetic_operator arithmetic_expression .)
    NOT_EQUAL       reduce using rule 63 (arithmetic_expression -> arithmetic_expression arithmetic_operator arithmetic_expression .)
    COMMA           reduce using rule 63 (arithmetic_expression -> arithmetic_expression arithmetic_operator arithmetic_expression .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVISION        shift and go to state 68
    MODULO          shift and go to state 69

  ! PLUS            [ reduce using rule 63 (arithmetic_expression -> arithmetic_expression arithmetic_operator arithmetic_expression .) ]
  ! MINUS           [ reduce using rule 63 (arithmetic_expression -> arithmetic_expression arithmetic_operator arithmetic_expression .) ]
  ! TIMES           [ reduce using rule 63 (arithmetic_expression -> arithmetic_expression arithmetic_operator arithmetic_expression .) ]
  ! DIVISION        [ reduce using rule 63 (arithmetic_expression -> arithmetic_expression arithmetic_operator arithmetic_expression .) ]
  ! MODULO          [ reduce using rule 63 (arithmetic_expression -> arithmetic_expression arithmetic_operator arithmetic_expression .) ]

    arithmetic_operator            shift and go to state 64

state 96

    (60) arithmetic_expression -> IDENTIFIER .

    PLUS            reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    MINUS           reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    TIMES           reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    DIVISION        reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    MODULO          reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    END             reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    )               reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    GT              reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    LT              reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    GE              reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    LE              reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    EQUAL           reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)
    COMMA           reduce using rule 60 (arithmetic_expression -> IDENTIFIER .)


state 97

    (62) arithmetic_expression -> ( . arithmetic_expression )
    (60) arithmetic_expression -> . IDENTIFIER
    (61) arithmetic_expression -> . arithmetic_literal
    (62) arithmetic_expression -> . ( arithmetic_expression )
    (63) arithmetic_expression -> . arithmetic_expression arithmetic_operator arithmetic_expression
    (70) arithmetic_literal -> . REAL
    (71) arithmetic_literal -> . INTEGER

    IDENTIFIER      shift and go to state 96
    (               shift and go to state 97
    REAL            shift and go to state 56
    INTEGER         shift and go to state 57

    arithmetic_expression          shift and go to state 115
    arithmetic_literal             shift and go to state 38

state 98

    (62) arithmetic_expression -> ( arithmetic_expression ) .

    PLUS            reduce using rule 62 (arithmetic_expression -> ( arithmetic_expression ) .)
    MINUS           reduce using rule 62 (arithmetic_expression -> ( arithmetic_expression ) .)
    TIMES           reduce using rule 62 (arithmetic_expression -> ( arithmetic_expression ) .)
    DIVISION        reduce using rule 62 (arithmetic_expression -> ( arithmetic_expression ) .)
    MODULO          reduce using rule 62 (arithmetic_expression -> ( arithmetic_expression ) .)
    END             reduce using rule 62 (arithmetic_expression -> ( arithmetic_expression ) .)
    )               reduce using rule 62 (arithmetic_expression -> ( arithmetic_expression ) .)
    GT              reduce using rule 62 (arithmetic_expression -> ( arithmetic_expression ) .)
    LT              reduce using rule 62 (arithmetic_expression -> ( arithmetic_expression ) .)
    GE              reduce using rule 62 (arithmetic_expression -> ( arithmetic_expression ) .)
    LE              reduce using rule 62 (arithmetic_expression -> ( arithmetic_expression ) .)
    EQUAL           reduce using rule 62 (arithmetic_expression -> ( arithmetic_expression ) .)
    NOT_EQUAL       reduce using rule 62 (arithmetic_expression -> ( arithmetic_expression ) .)
    COMMA           reduce using rule 62 (arithmetic_expression -> ( arithmetic_expression ) .)


state 99

    (31) note -> ( REAL COMMA . REAL COMMA INTEGER )

    REAL            shift and go to state 116


state 100

    (35) chord -> ( INTEGER COMMA . INTEGER COMMA INTEGER )

    INTEGER         shift and go to state 117


state 101

    (31) note -> ( . REAL COMMA REAL COMMA INTEGER )

    REAL            shift and go to state 118


state 102

    (41) music -> ( [ note_list . ] COMMA REAL )
    (40) note_list -> note_list . COMMA note

    ]               shift and go to state 119
    COMMA           shift and go to state 120


state 103

    (42) music -> ( [ ] . COMMA REAL )

    COMMA           shift and go to state 121


state 104

    (39) note_list -> note .

    ]               reduce using rule 39 (note_list -> note .)
    COMMA           reduce using rule 39 (note_list -> note .)


state 105

    (57) builtin_functions -> PREDEFINED_IDENTIFIER ( params_list . )
    (59) params_list -> params_list . COMMA expression

    )               shift and go to state 122
    COMMA           shift and go to state 123


state 106

    (58) params_list -> expression .

    )               reduce using rule 58 (params_list -> expression .)
    COMMA           reduce using rule 58 (params_list -> expression .)


state 107

    (34) scale -> [ integer_list ] .

    END             reduce using rule 34 (scale -> [ integer_list ] .)
    )               reduce using rule 34 (scale -> [ integer_list ] .)
    COMMA           reduce using rule 34 (scale -> [ integer_list ] .)


state 108

    (33) integer_list -> integer_list COMMA . INTEGER

    INTEGER         shift and go to state 124


state 109

    (38) harmonic_field -> [ chord_list ] .

    END             reduce using rule 38 (harmonic_field -> [ chord_list ] .)
    )               reduce using rule 38 (harmonic_field -> [ chord_list ] .)
    COMMA           reduce using rule 38 (harmonic_field -> [ chord_list ] .)


state 110

    (37) chord_list -> chord_list COMMA . chord
    (35) chord -> . ( INTEGER COMMA INTEGER COMMA INTEGER )

    (               shift and go to state 80

    chord                          shift and go to state 125

state 111

    (35) chord -> ( INTEGER . COMMA INTEGER COMMA INTEGER )

    COMMA           shift and go to state 100


state 112

    (67) logic_expression -> ( arithmetic_expression comparative_operator arithmetic_expression . )
    (63) arithmetic_expression -> arithmetic_expression . arithmetic_operator arithmetic_expression
    (13) arithmetic_operator -> . PLUS
    (14) arithmetic_operator -> . MINUS
    (15) arithmetic_operator -> . TIMES
    (16) arithmetic_operator -> . DIVISION
    (17) arithmetic_operator -> . MODULO

    )               shift and go to state 126
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVISION        shift and go to state 68
    MODULO          shift and go to state 69

    arithmetic_operator            shift and go to state 64

state 113

    (9) loop -> WHILE ( logic_expression ) { command . }
    (2) command -> command . command
    (2) command -> . command command
    (3) command -> . loop
    (4) command -> . if_conditional
    (5) command -> . if_else_conditional
    (6) command -> . variable_attribution END
    (7) command -> . variable_declaration END
    (8) command -> . register_command END
    (9) loop -> . WHILE ( logic_expression ) { command }
    (10) if_conditional -> . IF ( logic_expression ) { command }
    (11) if_else_conditional -> . IF ( logic_expression ) { command } ELSE { command }
    (43) variable_attribution -> . IDENTIFIER = expression
    (44) variable_declaration -> . VARIABLE_TYPE IDENTIFIER = expression
    (12) register_command -> . REGISTER ( expression )

    }               shift and go to state 127
    WHILE           shift and go to state 10
    IF              shift and go to state 11
    IDENTIFIER      shift and go to state 12
    VARIABLE_TYPE   shift and go to state 13
    REGISTER        shift and go to state 14

    command                        shift and go to state 15
    loop                           shift and go to state 4
    if_conditional                 shift and go to state 5
    if_else_conditional            shift and go to state 6
    variable_attribution           shift and go to state 7
    variable_declaration           shift and go to state 8
    register_command               shift and go to state 9

state 114

    (10) if_conditional -> IF ( logic_expression ) { command . }
    (11) if_else_conditional -> IF ( logic_expression ) { command . } ELSE { command }
    (2) command -> command . command
    (2) command -> . command command
    (3) command -> . loop
    (4) command -> . if_conditional
    (5) command -> . if_else_conditional
    (6) command -> . variable_attribution END
    (7) command -> . variable_declaration END
    (8) command -> . register_command END
    (9) loop -> . WHILE ( logic_expression ) { command }
    (10) if_conditional -> . IF ( logic_expression ) { command }
    (11) if_else_conditional -> . IF ( logic_expression ) { command } ELSE { command }
    (43) variable_attribution -> . IDENTIFIER = expression
    (44) variable_declaration -> . VARIABLE_TYPE IDENTIFIER = expression
    (12) register_command -> . REGISTER ( expression )

    }               shift and go to state 128
    WHILE           shift and go to state 10
    IF              shift and go to state 11
    IDENTIFIER      shift and go to state 12
    VARIABLE_TYPE   shift and go to state 13
    REGISTER        shift and go to state 14

    command                        shift and go to state 15
    loop                           shift and go to state 4
    if_conditional                 shift and go to state 5
    if_else_conditional            shift and go to state 6
    variable_attribution           shift and go to state 7
    variable_declaration           shift and go to state 8
    register_command               shift and go to state 9

state 115

    (62) arithmetic_expression -> ( arithmetic_expression . )
    (63) arithmetic_expression -> arithmetic_expression . arithmetic_operator arithmetic_expression
    (13) arithmetic_operator -> . PLUS
    (14) arithmetic_operator -> . MINUS
    (15) arithmetic_operator -> . TIMES
    (16) arithmetic_operator -> . DIVISION
    (17) arithmetic_operator -> . MODULO

    )               shift and go to state 98
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVISION        shift and go to state 68
    MODULO          shift and go to state 69

    arithmetic_operator            shift and go to state 64

state 116

    (31) note -> ( REAL COMMA REAL . COMMA INTEGER )

    COMMA           shift and go to state 129


state 117

    (35) chord -> ( INTEGER COMMA INTEGER . COMMA INTEGER )

    COMMA           shift and go to state 130


state 118

    (31) note -> ( REAL . COMMA REAL COMMA INTEGER )

    COMMA           shift and go to state 99


state 119

    (41) music -> ( [ note_list ] . COMMA REAL )

    COMMA           shift and go to state 131


state 120

    (40) note_list -> note_list COMMA . note
    (31) note -> . ( REAL COMMA REAL COMMA INTEGER )

    (               shift and go to state 101

    note                           shift and go to state 132

state 121

    (42) music -> ( [ ] COMMA . REAL )

    REAL            shift and go to state 133


state 122

    (57) builtin_functions -> PREDEFINED_IDENTIFIER ( params_list ) .

    END             reduce using rule 57 (builtin_functions -> PREDEFINED_IDENTIFIER ( params_list ) .)
    )               reduce using rule 57 (builtin_functions -> PREDEFINED_IDENTIFIER ( params_list ) .)
    COMMA           reduce using rule 57 (builtin_functions -> PREDEFINED_IDENTIFIER ( params_list ) .)


state 123

    (59) params_list -> params_list COMMA . expression
    (53) expression -> . arithmetic_expression
    (54) expression -> . logic_expression
    (55) expression -> . literal
    (56) expression -> . builtin_functions
    (60) arithmetic_expression -> . IDENTIFIER
    (61) arithmetic_expression -> . arithmetic_literal
    (62) arithmetic_expression -> . ( arithmetic_expression )
    (63) arithmetic_expression -> . arithmetic_expression arithmetic_operator arithmetic_expression
    (64) logic_expression -> . BOOLEAN
    (65) logic_expression -> . IDENTIFIER
    (66) logic_expression -> . ( logic_expression )
    (67) logic_expression -> . ( arithmetic_expression comparative_operator arithmetic_expression )
    (68) logic_expression -> . logic_expression binary_logic_operator logic_expression
    (69) logic_expression -> . unary_logic_operator logic_expression
    (45) literal -> . note
    (46) literal -> . scale
    (47) literal -> . chord
    (48) literal -> . harmonic_field
    (49) literal -> . music
    (50) literal -> . INTEGER
    (51) literal -> . REAL
    (52) literal -> . BOOLEAN
    (57) builtin_functions -> . PREDEFINED_IDENTIFIER ( params_list )
    (70) arithmetic_literal -> . REAL
    (71) arithmetic_literal -> . INTEGER
    (20) unary_logic_operator -> . NOT
    (31) note -> . ( REAL COMMA REAL COMMA INTEGER )
    (34) scale -> . [ integer_list ]
    (35) chord -> . ( INTEGER COMMA INTEGER COMMA INTEGER )
    (38) harmonic_field -> . [ chord_list ]
    (41) music -> . ( [ note_list ] COMMA REAL )
    (42) music -> . ( [ ] COMMA REAL )

    IDENTIFIER      shift and go to state 32
    (               shift and go to state 39
    BOOLEAN         shift and go to state 40
    INTEGER         shift and go to state 46
    REAL            shift and go to state 47
    PREDEFINED_IDENTIFIER shift and go to state 48
    NOT             shift and go to state 30
    [               shift and go to state 49

    expression                     shift and go to state 134
    arithmetic_expression          shift and go to state 34
    logic_expression               shift and go to state 35
    literal                        shift and go to state 36
    builtin_functions              shift and go to state 37
    arithmetic_literal             shift and go to state 38
    unary_logic_operator           shift and go to state 29
    note                           shift and go to state 41
    scale                          shift and go to state 42
    chord                          shift and go to state 43
    harmonic_field                 shift and go to state 44
    music                          shift and go to state 45

state 124

    (33) integer_list -> integer_list COMMA INTEGER .

    ]               reduce using rule 33 (integer_list -> integer_list COMMA INTEGER .)
    COMMA           reduce using rule 33 (integer_list -> integer_list COMMA INTEGER .)


state 125

    (37) chord_list -> chord_list COMMA chord .

    ]               reduce using rule 37 (chord_list -> chord_list COMMA chord .)
    COMMA           reduce using rule 37 (chord_list -> chord_list COMMA chord .)


state 126

    (67) logic_expression -> ( arithmetic_expression comparative_operator arithmetic_expression ) .

    )               reduce using rule 67 (logic_expression -> ( arithmetic_expression comparative_operator arithmetic_expression ) .)
    AND             reduce using rule 67 (logic_expression -> ( arithmetic_expression comparative_operator arithmetic_expression ) .)
    OR              reduce using rule 67 (logic_expression -> ( arithmetic_expression comparative_operator arithmetic_expression ) .)
    END             reduce using rule 67 (logic_expression -> ( arithmetic_expression comparative_operator arithmetic_expression ) .)
    COMMA           reduce using rule 67 (logic_expression -> ( arithmetic_expression comparative_operator arithmetic_expression ) .)


state 127

    (9) loop -> WHILE ( logic_expression ) { command } .

    }               reduce using rule 9 (loop -> WHILE ( logic_expression ) { command } .)
    WHILE           reduce using rule 9 (loop -> WHILE ( logic_expression ) { command } .)
    IF              reduce using rule 9 (loop -> WHILE ( logic_expression ) { command } .)
    IDENTIFIER      reduce using rule 9 (loop -> WHILE ( logic_expression ) { command } .)
    VARIABLE_TYPE   reduce using rule 9 (loop -> WHILE ( logic_expression ) { command } .)
    REGISTER        reduce using rule 9 (loop -> WHILE ( logic_expression ) { command } .)


state 128

    (10) if_conditional -> IF ( logic_expression ) { command } .
    (11) if_else_conditional -> IF ( logic_expression ) { command } . ELSE { command }

    }               reduce using rule 10 (if_conditional -> IF ( logic_expression ) { command } .)
    WHILE           reduce using rule 10 (if_conditional -> IF ( logic_expression ) { command } .)
    IF              reduce using rule 10 (if_conditional -> IF ( logic_expression ) { command } .)
    IDENTIFIER      reduce using rule 10 (if_conditional -> IF ( logic_expression ) { command } .)
    VARIABLE_TYPE   reduce using rule 10 (if_conditional -> IF ( logic_expression ) { command } .)
    REGISTER        reduce using rule 10 (if_conditional -> IF ( logic_expression ) { command } .)
    ELSE            shift and go to state 135


state 129

    (31) note -> ( REAL COMMA REAL COMMA . INTEGER )

    INTEGER         shift and go to state 136


state 130

    (35) chord -> ( INTEGER COMMA INTEGER COMMA . INTEGER )

    INTEGER         shift and go to state 137


state 131

    (41) music -> ( [ note_list ] COMMA . REAL )

    REAL            shift and go to state 138


state 132

    (40) note_list -> note_list COMMA note .

    ]               reduce using rule 40 (note_list -> note_list COMMA note .)
    COMMA           reduce using rule 40 (note_list -> note_list COMMA note .)


state 133

    (42) music -> ( [ ] COMMA REAL . )

    )               shift and go to state 139


state 134

    (59) params_list -> params_list COMMA expression .

    )               reduce using rule 59 (params_list -> params_list COMMA expression .)
    COMMA           reduce using rule 59 (params_list -> params_list COMMA expression .)


state 135

    (11) if_else_conditional -> IF ( logic_expression ) { command } ELSE . { command }

    {               shift and go to state 140


state 136

    (31) note -> ( REAL COMMA REAL COMMA INTEGER . )

    )               shift and go to state 141


state 137

    (35) chord -> ( INTEGER COMMA INTEGER COMMA INTEGER . )

    )               shift and go to state 142


state 138

    (41) music -> ( [ note_list ] COMMA REAL . )

    )               shift and go to state 143


state 139

    (42) music -> ( [ ] COMMA REAL ) .

    END             reduce using rule 42 (music -> ( [ ] COMMA REAL ) .)
    )               reduce using rule 42 (music -> ( [ ] COMMA REAL ) .)
    COMMA           reduce using rule 42 (music -> ( [ ] COMMA REAL ) .)


state 140

    (11) if_else_conditional -> IF ( logic_expression ) { command } ELSE { . command }
    (2) command -> . command command
    (3) command -> . loop
    (4) command -> . if_conditional
    (5) command -> . if_else_conditional
    (6) command -> . variable_attribution END
    (7) command -> . variable_declaration END
    (8) command -> . register_command END
    (9) loop -> . WHILE ( logic_expression ) { command }
    (10) if_conditional -> . IF ( logic_expression ) { command }
    (11) if_else_conditional -> . IF ( logic_expression ) { command } ELSE { command }
    (43) variable_attribution -> . IDENTIFIER = expression
    (44) variable_declaration -> . VARIABLE_TYPE IDENTIFIER = expression
    (12) register_command -> . REGISTER ( expression )

    WHILE           shift and go to state 10
    IF              shift and go to state 11
    IDENTIFIER      shift and go to state 12
    VARIABLE_TYPE   shift and go to state 13
    REGISTER        shift and go to state 14

    command                        shift and go to state 144
    loop                           shift and go to state 4
    if_conditional                 shift and go to state 5
    if_else_conditional            shift and go to state 6
    variable_attribution           shift and go to state 7
    variable_declaration           shift and go to state 8
    register_command               shift and go to state 9

state 141

    (31) note -> ( REAL COMMA REAL COMMA INTEGER ) .

    END             reduce using rule 31 (note -> ( REAL COMMA REAL COMMA INTEGER ) .)
    )               reduce using rule 31 (note -> ( REAL COMMA REAL COMMA INTEGER ) .)
    ]               reduce using rule 31 (note -> ( REAL COMMA REAL COMMA INTEGER ) .)
    COMMA           reduce using rule 31 (note -> ( REAL COMMA REAL COMMA INTEGER ) .)


state 142

    (35) chord -> ( INTEGER COMMA INTEGER COMMA INTEGER ) .

    END             reduce using rule 35 (chord -> ( INTEGER COMMA INTEGER COMMA INTEGER ) .)
    )               reduce using rule 35 (chord -> ( INTEGER COMMA INTEGER COMMA INTEGER ) .)
    ]               reduce using rule 35 (chord -> ( INTEGER COMMA INTEGER COMMA INTEGER ) .)
    COMMA           reduce using rule 35 (chord -> ( INTEGER COMMA INTEGER COMMA INTEGER ) .)


state 143

    (41) music -> ( [ note_list ] COMMA REAL ) .

    END             reduce using rule 41 (music -> ( [ note_list ] COMMA REAL ) .)
    )               reduce using rule 41 (music -> ( [ note_list ] COMMA REAL ) .)
    COMMA           reduce using rule 41 (music -> ( [ note_list ] COMMA REAL ) .)


state 144

    (11) if_else_conditional -> IF ( logic_expression ) { command } ELSE { command . }
    (2) command -> command . command
    (2) command -> . command command
    (3) command -> . loop
    (4) command -> . if_conditional
    (5) command -> . if_else_conditional
    (6) command -> . variable_attribution END
    (7) command -> . variable_declaration END
    (8) command -> . register_command END
    (9) loop -> . WHILE ( logic_expression ) { command }
    (10) if_conditional -> . IF ( logic_expression ) { command }
    (11) if_else_conditional -> . IF ( logic_expression ) { command } ELSE { command }
    (43) variable_attribution -> . IDENTIFIER = expression
    (44) variable_declaration -> . VARIABLE_TYPE IDENTIFIER = expression
    (12) register_command -> . REGISTER ( expression )

    }               shift and go to state 145
    WHILE           shift and go to state 10
    IF              shift and go to state 11
    IDENTIFIER      shift and go to state 12
    VARIABLE_TYPE   shift and go to state 13
    REGISTER        shift and go to state 14

    command                        shift and go to state 15
    loop                           shift and go to state 4
    if_conditional                 shift and go to state 5
    if_else_conditional            shift and go to state 6
    variable_attribution           shift and go to state 7
    variable_declaration           shift and go to state 8
    register_command               shift and go to state 9

state 145

    (11) if_else_conditional -> IF ( logic_expression ) { command } ELSE { command } .

    }               reduce using rule 11 (if_else_conditional -> IF ( logic_expression ) { command } ELSE { command } .)
    WHILE           reduce using rule 11 (if_else_conditional -> IF ( logic_expression ) { command } ELSE { command } .)
    IF              reduce using rule 11 (if_else_conditional -> IF ( logic_expression ) { command } ELSE { command } .)
    IDENTIFIER      reduce using rule 11 (if_else_conditional -> IF ( logic_expression ) { command } ELSE { command } .)
    VARIABLE_TYPE   reduce using rule 11 (if_else_conditional -> IF ( logic_expression ) { command } ELSE { command } .)
    REGISTER        reduce using rule 11 (if_else_conditional -> IF ( logic_expression ) { command } ELSE { command } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for WHILE in state 15 resolved as shift
WARNING: shift/reduce conflict for IF in state 15 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 15 resolved as shift
WARNING: shift/reduce conflict for VARIABLE_TYPE in state 15 resolved as shift
WARNING: shift/reduce conflict for REGISTER in state 15 resolved as shift
WARNING: shift/reduce conflict for AND in state 62 resolved as shift
WARNING: shift/reduce conflict for OR in state 62 resolved as shift
WARNING: shift/reduce conflict for AND in state 93 resolved as shift
WARNING: shift/reduce conflict for OR in state 93 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 95 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 95 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 95 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 95 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 95 resolved as shift
WARNING: reduce/reduce conflict in state 32 resolved using rule (arithmetic_expression -> IDENTIFIER)
WARNING: rejected rule (logic_expression -> IDENTIFIER) in state 32
WARNING: reduce/reduce conflict in state 40 resolved using rule (literal -> BOOLEAN)
WARNING: rejected rule (logic_expression -> BOOLEAN) in state 40
WARNING: reduce/reduce conflict in state 46 resolved using rule (literal -> INTEGER)
WARNING: rejected rule (arithmetic_literal -> INTEGER) in state 46
WARNING: reduce/reduce conflict in state 47 resolved using rule (literal -> REAL)
WARNING: rejected rule (arithmetic_literal -> REAL) in state 47
WARNING: reduce/reduce conflict in state 55 resolved using rule (arithmetic_expression -> IDENTIFIER)
WARNING: rejected rule (logic_expression -> IDENTIFIER) in state 55
